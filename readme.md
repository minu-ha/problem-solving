브라우저 동작 원리
=============

### 브라우저

클라이언트가 접속하고자 하는 웹페이지를 주소에 입력하면, DNS 서버에 접속하려는 주소의 IP 주소를 요청하고
DNS 서버에서 IP 주소를 알려준 뒤 접속하게된다.

브라우저는 서버로부터 HTML,CSS,JS 파일 등등을 받고, HTML, CSS를 파싱한 후 DOM,CSSOM으로 변환 된 후 렌더
트리로 결합한다. 브라우저는 이를 기반으로 웹페이지를 표시한다.

### 자바스크립트

### JS

JS의 경우, 렌더링 엔진이 아닌 자바스크립트 엔진이 처리하고, HTML 파서가 스크립트를 만나면 DOM 생성을 중지하고
자바스크립트 엔진은 스크립트 파일을 로드하고 파싱하여 실행한다. 과정이 끝나면 HTML 파서는 DOM 생성을 재개한다.

BODY 요소의 가장 아래에 스크립트를 위치시키는 이유로는 HTML이 로딩되기 전에 자바스크립트가 DOM을 조작하는 경우
에러가 날 수 있고, DOM을 생성하는 도중 자바스크립트 로딩으로 인하여 페이지 로딩이 길어질 수 있기 떄문이다.

### VAR 변수의 문제점

키워드의 생략을 허용하고, 중복 선언이 가능하며, 호이스팅으로 인하여 선언하기 전에 참조가 가능하다,
함수레벨 스코프기 때문에 전역에서 참조 할 수 있다.

### 스코프

```js
var x = 'global'

function foo() {
    var x = 'function scope';
    console.log(x);
}

foo();
console.log(x);
```

스코프란 참조 대상 식별자를 찾아내기 위한 규칙이다.   
전역에 선언된 x는 어디에서든 참조가 가능하지만 함수 foo에 선언된 x는 함수 내부에서만 참조 할 수 있다.

스코프는 전역 스코프와 지역 스코프로 구분되며. 변수의 관점에서는 전역변수와 지역변수로 부를 수 있다.   
선언 위치에 따라 스코프에 차이가 있다.

```js
var x = 0;
{
    var x = 1;
    console.log(x); // 1
}
console.log(x);   // 1

let y = 0;
{
    let y = 1;
    console.log(y); // 1
}
console.log(y);   // 0
```

자바스크립트는 함수레벨 스코프를 사용하는 언어이기 떄문에 블록내에서 선언된 변수라도 같은 함수 내에
위치하고있으면 참조가 가능하다. 변수명이 중복된 경우 지역변수를 우선하여 참조한다.

```js
var x = 'global';

function foo() {
    var x = 'local';
    console.log(x);

    function bar() {  // 내부함수
        console.log(x); // ?
    }

    bar();
}

foo();
console.log(x); // ?
```

내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근 할 수 있다. 실행 컨텍스트의 스코프 체인에 의해
전역변수 x가 뒤로 밀려났기 때문이다.

```js
var x = 1;

function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo(); // ?
bar(); // ?
```

자바스크립트는 함수를 호출한 시점이 아닌 선언한 시점에서 상위 스코프가 결정되는 렉시컬 스코프를 따른다.

### THIS

자바스크립트는 함수 호출 방식에 의해 this에 바인딩할 객체가 동적으로 결정된다.

* 함수 호출
* 메소드 호출
* 생성자 함수 호출
* apply / call / bind gㅗ출

기본적으로 this는 전역객체에 바인딩된다. 전역함수 & 내부함수 & 콜백함수에서도 차이는 없다.

```js
var obj1 = {
    name: 'Lee',
    sayName: function () {
        console.log(this.name);
    }
}

var obj2 = {
    name: 'Kim'
}

obj2.sayName = obj1.sayName;

obj1.sayName();
obj2.sayName();
```

함수가 객체의 프로퍼티면 메소드로 호출된다. 메소드 내부의 this는 메소드를 호출한 객체에 바인딩된다.

### 실행 컨텍스트

실행 컨텍스트는 실행 가능한 코드를 형상화하고 객체의 형태를 가지고있으며, Value Object, Scope Chain, This
를 갖고있다.

### 클로저

클로저란 함수와 그 함수가 선언됐을 때의 렉시컬 환경과의 조합.
자신을 포함하고있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부함수 밖에서 내부함수가 호출되더라도
외부함수의 지역변수에 접근 할 수 있다. 자신이 생성될 때의 환경을 기억하는 함수.